library(magrittr, include.only = "%>%")

# upgrade of addFeatures from cummeRbund package, was using deprecated functions
.addFeatures <- function(object, features, level = "genes", ...) { # nolint
  if (!is.data.frame(features)) {
    stop("features must be a data.frame")
  }
  colnames(features)[1] <- slot(object, level)@idField
  colnames(features) <- make.db.names(object@DB,
    colnames(features),
    unique = TRUE
  )
  DBI::dbWriteTable(object@DB,
    slot(object, level)@tables$featureTable,
    features,
    row.names = FALSE,
    overwrite = TRUE
  )
  indexQuery <- paste( # nolint
    "CREATE INDEX ",
    slot(object, level)@idField,
    " ON ",
    slot(object, level)@tables$featureTable,
    " (",
    slot(object, level)@idField,
    ")",
    sep = ""
  )
  res <- DBI::dbExecute(object@DB, indexQuery)
}
setMethod("addFeatures", signature(object = "CuffSet"), .addFeatures)

# user defined reading functions -----------------------------------------------
read_data <- function(filename) {
  ext <- tools::file_ext(filename)
  if (ext %in% c("tsv", "txt")) {
    separator <- "\t"
  } else if (ext %in% c("csv")) {
    separator <- ","
  }
  data <- readr::read_delim(filename,
    delim = separator,
    col_names = TRUE,
    escape_double = FALSE,
    trim_ws = TRUE
  )
  return(data)
}

read_gene_list_from_file = function(filename) {
  gene_list = readr::read_delim(filename, 
                                delim = "\t", 
                                col_names = c("SYMBOL")) %>%
    dplyr::pull(SYMBOL)
  return(gene_list)
}

read_cuffdiff <- function(dir) {
  cuff <- cummeRbund::readCufflinks(dir)
  annot <- read.delim(paste0(dir, "/gene_exp.diff"),
    sep = "\t",
    header = TRUE,
    na.string = "-"
  ) %>%
    dplyr::select(gene_id, gene)
  cummeRbund::addFeatures(cuff, annot, level = "genes")

  # munging of differential expression data
  diff <- cummeRbund::diffData(cummeRbund::genes(cuff)) %>%
    tibble::as_tibble()
  diff <- diff %>%
    dplyr::filter(value_1 > 0 & value_2 > 0) %>%
    dplyr::filter(status == "OK")
  diff <- diff %>%
    dplyr::mutate(comparison = paste0(sample_1, "_", sample_2)) %>%
    dplyr::left_join(annot %>% unique())
  return(diff)
}

read_dire_xlsx <- function(filename, sheet_name = "Sheet1") {
  if (grepl(".xlsx", filename)) {
    data <- readxl::read_excel(filename, sheet = sheet_name) %>%
      dplyr::select(-`#`)
  } else {
    data <- readr::read_delim(filename) %>%
      dplyr::select(-`#`)
  }
  return(data)
}

collate_dire_pathways <- function(pathway_files_basepath,
                                  pattern,
                                  sheet_name) {
  pathway_files <- list.files(
    pathway_files_basepath,
    pattern = pattern,
    full.names = TRUE
  )

  dire_pathways <- purrr::map_dfr(pathway_files, function(x) {
    if (endsWith(x, "xlsx")) {
      dire_df <- read_dire_xlsx(x, dire_sheet_name)
    } else {
      dire_df <- read_data(x) %>%
      dplyr::select(-`#`) %>%
        mutate(Occurrence = as.numeric(gsub("%", "", Occurrence)) / 100)
    }
    dire_df <- dire_df %>%
      dplyr::mutate(file = x)
  })
  return(dire_pathways)
}

# jsonfile generated by http://amigo.geneontology.org/amigo
# preserves pathway hierarchy
read_amigo_json <- function(jsonfile) {
  purrr::map_dfr(jsonfile$overrepresentation$group, function(y) {
    if (length(y$result) == 3 &
      !is.list(y$result[[2]])) {
      data.frame(t(c(
        id = y$result$term$id,
        label = y$result$term$label,
        fold_enrichment = y$result$input_list$fold_enrichment,
        pvalue = y$result$input_list$pValue,
        level = y$result$term$level
      )))
    } else {
      purrr::map_dfr(y$result, function(x) {
        data.frame(t(c(
          id = x$term$id,
          label = x$term$label,
          fold_enrichment = x$input_list$fold_enrichment,
          pvalue = x$input_list$pValue,
          level = x$term$level
        )))
      })
    }
  }) %>%
    tidyr::drop_na() %>%
    dplyr::mutate(
      fold_enrichment = as.double(fold_enrichment),
      pvalue = as.double(pvalue),
      level = as.integer(level)
    )
}

read_gsea <- function(filename, rank_by = nes, descending = TRUE) {
  orientation <- rank_how(descending)

  read.table(filename, header = TRUE, sep = "\t") %>%
    dplyr::select(-X) %>%
    setNames(c(
      "name", "link", "details", "size", "es", "nes", "nom_pval",
      "fdr_qval", "fwer_pval", "rank_at_max", "leading_edge"
    )) %>%
    dplyr::mutate(file = filename) %>%
    dplyr::arrange(orientation(abs({{ rank_by }}))) %>%
    dplyr::mutate(pathway_rank = dplyr::row_number()) %>%
    dplyr::mutate(nom_pval = nom_pval + 0.00001) %>%
    dplyr::mutate(fdr_qval = fdr_qval + 0.00001)
}

get_gsea_files_from_dir <- function(dirpath, pattern) {
  file_df <- data.frame(full_path = dir(dirpath,
    pattern = paste0(pattern, ".*tsv"),
    full.names = TRUE,
    recursive = TRUE
  )) %>%
    tidyr::separate(full_path,
      into = c("path", "file"),
      sep = paste0("/", pattern),
      remove = FALSE
    ) %>%
    dplyr::mutate(file = paste0(pattern, file))
  return(file_df)
}

filter_pathways <- function(pathway_data, score_column, pvalue_column, rank_by,
                            score_threshold = 0, pvalue_threshold = 0.05,
                            descending = TRUE) {
  orientation <- rank_how(descending)

  pathway_data %>%
    dplyr::filter(abs({{ score_column }}) > score_threshold) %>%
    dplyr::filter({{ pvalue_column }} < pvalue_threshold) %>%
    dplyr::arrange(orientation(abs({{ rank_by }}))) %>%
    dplyr::mutate(pathway_rank = dplyr::row_number())
}


batch_read_filter_gsea <- function(dir = ".",
                                   pattern = "gsea_report_for",
                                   score_threshold = 0,
                                   pvalue_threshold = 0.05) {
  files_df <- get_gsea_files_from_dir(dir, pattern)

  purrr::map_dfr(unique(files_df$path), function(x) {
    filtered_df <- files_df %>%
      dplyr::filter(path == x)
    purrr::map_dfr(filtered_df$file, function(y) {
      read_gsea(paste0(x, "/", y))
    }) %>%
      filter_pathways(
        score_column = nes,
        pvalue_column = fdr_qval,
        rank_by = nes,
        score_threshold = score_threshold,
        pvalue_threshold = pvalue_threshold
      )
  })
}

# TODO switch to collating based on directory
read_ipa <- function(filename, rank_by = zscore, descending = TRUE) {
  orientation <- rank_how(descending)

  read.table(filename, header = TRUE, sep = "\t") %>%
    dplyr::arrange(orientation(abs({{ rank_by }}))) %>%
    dplyr::mutate(pathway_rank = dplyr::row_number())
}

collate_ipa_pathways <- function(pathway_files_basepath,
                                 pattern,
                                 rank_by = zscore,
                                 descending = TRUE) {
  pathway_files <- list.files(
    pathway_files_basepath,
    pattern = pattern,
    full.names = FALSE
  )

  ipa_pathways <- purrr::map_dfr(pathway_files, function(x) {
    # TODO add df type to ipa pipeline
    read_ipa(x, rank_by = rank_by, descending = descending)
  })
  return(ipa_pathways)
}

collate_cp_pathways <- function(pathway_files_basepath,
                                pattern,
                                padj_threshold = 0.05) {
  pathway_files <- list.files(pathway_files_basepath,
    pattern = pattern,
    full.names = FALSE
  )

  cp_unified_colnames <- c(
    "ID", "Description", "GeneRatio/NES", "pvalue",
    "p.adjust", "SYMBOL", "ENTREZID", "log2FoldChange"
  )

  diffexp_pathways <- purrr::map_dfr(pathway_files, function(x) {
    readr::read_delim(paste0(pathway_files_basepath, x),
      delim = "\t", escape_double = FALSE,
      trim_ws = TRUE,
      show_col_types = FALSE
    ) %>%
      setNames(cp_unified_colnames) %>%
      # TODO needs to be changed
      dplyr::mutate(
        source = gsub("_contrast.txt", "", x),
        ID = as.character(ID)
      ) %>%
      # might not reflect actual columns
      # TODO fix
      dplyr::select(-SYMBOL, -ENTREZID, -log2FoldChange) %>%
      unique()
  }) %>%
    dplyr::filter(p.adjust < padj_threshold)
  return(diffexp_pathways)
}
