# upgrade of addFeatures from cummeRbund package, was using deprecated functions
.addFeatures <- function(object, features, level = "genes", ...) {
  if (!is.data.frame(features)) {
    stop("features must be a data.frame")
  }
  colnames(features)[1] <- slot(object, level)@idField
  colnames(features) <- make.db.names(object@DB, colnames(features), unique = T)
  DBI::dbWriteTable(object@DB, slot(object, level)@tables$featureTable, features, row.names = F, overwrite = T)
  indexQuery <- paste("CREATE INDEX ", slot(object, level)@idField, " ON ",
    slot(object, level)@tables$featureTable, " (", slot(object, level)@idField, ")",
    sep = ""
  )
  res <- DBI::dbExecute(object@DB, indexQuery)
}
setMethod("addFeatures", signature(object = "CuffSet"), .addFeatures)

# user defined reading functions -----------------------------------------------
read_cuffdiff_diff <- function(dir) {
  cuff <- cummeRbund::readCufflinks(dir)
  annot <- read.delim(paste0(dir, "/gene_exp.diff"),
    sep = "\t",
    header = T,
    na.string = "-"
  ) %>%
    dplyr::select(gene_id, gene)
  cummeRbund::addFeatures(cuff, annot, level = "genes")

  # munging of differential expression data
  diff <- cummeRbund::diffData(cummeRbund::genes(cuff)) %>%
    tibble::as_tibble()
  diff <- diff %>%
    dplyr::filter(value_1 > 0 & value_2 > 0) %>%
    dplyr::filter(status == "OK")
  diff <- diff %>%
    dplyr::mutate(comparison = paste0(sample_1, "_", sample_2)) %>%
    dplyr::left_join(annot %>% unique())
  return(diff)
}

read_dire_xlsx <- function(filename, sheet_name = "Sheet1") {

  # dire_df = function(fl) {
  #   conn = file(fl,open="r")
  #   linn = readLines(conn)
  #   linn =  matrix(linn, ncol = 4, byrow = T)
  #   print(linn)
  #   linn = data.frame(linn, stringsAsFactors = F)
  #   linn[,1] = NULL
  #   names(linn) = c("tf", "occurence", "importance")
  #   linn$occurence = as.numeric(gsub("%", "", linn$occurence))
  #   linn$importance = as.numeric(linn$importance)
  #   close(conn)
  #   return(linn)
  # }


  if (grepl(".xlsx", filename)) {
    data <- readxl::read_excel(filename, sheet = sheet_name) %>%
      dplyr::select(-`#`)
  } else {
    data <- readr::read_delim(filename) %>%
      dplyr::select(-`#`)
  }
  return(data)
}

# jsonfile generated by http://amigo.geneontology.org/amigo preserves pathway hierarchy
read_amigo_json = function(jsonfile) {
  map_dfr(jsonfile$overrepresentation$group, function(y) {
    if(length(y$result) == 3 &
       !is.list(y$result[[2]])) {
      data.frame(t(c(id = y$result$term$id,
                     label = y$result$term$label,
                     fold_enrichment = y$result$input_list$fold_enrichment,
                     pvalue = y$result$input_list$pValue,
                     level = y$result$term$level)))
    } else {
      map_dfr(y$result, function(x) {
        data.frame(t(c(id = x$term$id,
                       label = x$term$label,
                       fold_enrichment = x$input_list$fold_enrichment,
                       pvalue = x$input_list$pValue,
                       level = x$term$level)))
      })
    }
  }) %>%
    drop_na() %>%
    mutate(fold_enrichment = as.double(fold_enrichment),
           pvalue = as.double(pvalue),
           level = as.integer(level))
}

read_gsea = function(filename, rank_by = nes, descending = T) {
  orientation = rank_how(descending)
  
  read.table(filename, header = TRUE, sep = "\t") %>%
    dplyr::select(-X) %>%
    setNames(c("name", "link", "details", "size", "es", "nes", "nom_pval", 
               "fdr_qval", "fwer_pval", "rank_at_max", "leading_edge")) %>%
    mutate(file = filename) %>%
    arrange(orientation(abs({{ rank_by }}))) %>%
    mutate(pathway_rank = row_number()) %>%
    mutate(nom_pval = nom_pval + 0.00001) %>%
    mutate(fdr_qval = fdr_qval + 0.00001)
}

get_gsea_files_from_dir = function(dirpath, pattern) {
  file_df = data.frame(full_path = dir(dirpath, 
                                       pattern=paste0(pattern,".*tsv"), 
                                       full.names = T, 
                                       recursive = T)) %>%
    separate(full_path, into = c("path", "file"), sep = paste0("/", pattern), remove = F) %>%
    mutate(file = paste0(pattern, file))
  return(file_df)
}

filter_pathways = function(pathway_data, score_column, pvalue_column, rank_by,
                           score_threshold = 0, pvalue_threshold = 0.05,
                           descending = T) {
 
  orientation = rank_how(descending)
  
  pathway_data %>%
    filter(abs({{ score_column }}) > score_threshold) %>%
    filter({{ pvalue_column }} < pvalue_threshold ) %>%
    arrange(orientation(abs({{ rank_by }}))) %>%
    mutate(pathway_rank = row_number())
}


batch_read_filter_gsea = function(dir = ".", 
                                  pattern = "gsea_report_for",
                                  score_threshold = 0, 
                                  pvalue_threshold = 0.05) {
  
  files_df = get_gsea_files_from_dir(dir, pattern)
  
  map_dfr(unique(files_df$path), function(x) {
    filtered_df = files_df %>%
      filter(path == x)
    map_dfr(filtered_df$file, function(y) {
      read_gsea(paste0(x, "/", y)) 
    }) %>%
      filter_pathways(score_column = nes, 
                      pvalue_column = fdr_qval, 
                      rank_by = nes,
                      score_threshold = score_threshold,
                      pvalue_threshold = pvalue_threshold)
  })
}

read_ipa = function(filename, rank_by = zscore, descending = T) {
  orientation = rank_how(descending)
  
  read.table(filename, header = TRUE, sep = "\t") %>%
    arrange(orientation(abs({{ rank_by }}))) %>%
    mutate(pathway_rank = row_number())
}
